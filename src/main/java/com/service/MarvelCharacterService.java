package com.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.annotation.PostConstruct;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Subquery;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import com.entity.MarvelCharacter;
import com.repository.MarvelCharacterRepository;
import com.repository.specification.MarvelCharacterSpecifications;

@Service
public class MarvelCharacterService {

	@Autowired
	MarvelCharacterRepository marvelrepo;
	
	@PostConstruct
	public void init() {
		List<MarvelCharacter> chars = 
				List.of(
						MarvelCharacter
					    .builder()
					    .heroName("t123")		// no autogenerated id
					    .firstName("Tony")
					    .lastName("Stark")
					    .build(), 
					    MarvelCharacter
					    .builder()
					    .heroName("a123")		// no autogenerated id
					    .firstName("Alvarez")
					    .lastName("Senio")
					    .build());
		
		marvelrepo.saveAll(chars);
	}
	
	// using builder pattern, its something but this doesnt scale well
	public List<MarvelCharacter> findByBuilder(String firstName, String lastName) {
		
		MarvelCharacter example = MarvelCharacter
			    .builder()
			    .firstName(firstName)
			    .lastName(lastName)
			    .build();
			return marvelrepo.findAll(Example.of(example));
	}
	
//	The specification API is an abstraction on top of the JPA Criteria API, which means we can do anything you could 
//	do with these criteria as well.	Bit hard code, need list predications
	public List<MarvelCharacter> findBySpecification(String firstName, String lastName) {
		
		Specification<MarvelCharacter> specification = Specification
			    .where(firstName == null ? null : MarvelCharacterSpecifications.firstNameContains(firstName))
			    .and(lastName == null ? null : MarvelCharacterSpecifications.lastNameContains(lastName));
		
		return marvelrepo.findAll(specification);
	}	

	
	// returns a specification for multiple lastnames, add it into predicates array
	public static Specification<MarvelCharacter> lastNameIn(String... values) 
	{
	    return (root, query, builder) -> builder.or(Arrays
	        .stream(values)
	        .map(value -> builder.equal(root.get("lastName"), value))
	        .toArray(Predicate[]::new));
	}
	
	// bigger complex specification
	public static Specification<MarvelCharacter> findBySpecification2() {
	
		return (root, query, builder) ->  
		{
			// just revrite this, no subquery needed
			Subquery<MarvelCharacter> subquery = query.subquery(MarvelCharacter.class);
			Root<MarvelCharacter> subroot = subquery.from(MarvelCharacter.class);
			
			Predicate[] predicates = new Predicate[2];
			
			predicates[0] = builder.equal(subroot.get("firstName"), "Tony");
			predicates[1] = builder.equal(subroot.get("id"), root.get("id"));
			
			return builder.exists(subquery.select(subroot).where(predicates));
		};
		
	}
	

	// how about select only some columns ? use multiselect, stream.map() is too greedy/wastfeul resource
	public List<MarvelCharacter> findBySpecificationNormalizedOK(String firstName, String lastName) {
		
		Specification<MarvelCharacter> specification = (root, query, builder) -> {
			
		    List<Predicate> predicates = new ArrayList<>();

		    // like
		    predicates.add(builder.like(root.get("firstName"), firstName));

		    // equal
		    predicates.add(builder.equal(root.get("lastName"), lastName));


		    // AND all predicates
		    return builder.and(predicates.toArray(new Predicate[0]));
		};

		return marvelrepo.findAll(specification);
		
	}
	

	
	public List<MarvelCharacter> findBySpecificationNormalized45(String firstName, String lastName) {
		
		Specification<MarvelCharacter> specification = (root, query, builder) ->  
		{
			Subquery<MarvelCharacter> subquery = query.subquery(MarvelCharacter.class);
			Root<MarvelCharacter> subroot = subquery.from(MarvelCharacter.class);
			
			Predicate[] predicates = new Predicate[2];
			
			predicates[0] = builder.equal(root.get("firstName"), firstName);
			predicates[1] = builder.equal(root.get("lastName"), lastName);
			
			return builder.exists(subquery.select(subroot).where(predicates));
		};
		
		return marvelrepo.findAll(specification);
	}
}






//// bigger complex specification
//public List<MarvelCharacter> findBySpecificationNormalized(String firstName, String lastName) {
//
//	Specification<MarvelCharacter> specification = (root, query, builder) ->  
//	{
////		Root<MarvelCharacter> root_m = query.from(MarvelCharacter.class);		// no, we already have the root injected you idiot
//		
//		Predicate[] predicates = new Predicate[2];
//		
//		predicates[0] = builder.equal(root.get("firstName"), firstName);
//		predicates[1] = builder.equal(root.get("lastName"), lastName);
//		
//		Predicate finalPredicate = builder.and(predicates);
//		
//		return finalPredicate;
//	};
//	
//	return marvelrepo.findAll(specification);
//}







